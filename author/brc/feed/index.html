<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Portcullis Labs &#187; BRC</title>
	<atom:link href="https://labs.portcullis.co.uk/author/brc/feed/" rel="self" type="application/rss+xml" />
	<link>https://labs.portcullis.co.uk</link>
	<description>Research and Development</description>
	<language>en-US</language>
		<sy:updatePeriod>hourly</sy:updatePeriod>
		<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.8.5</generator>
	<item>
		<title>Using Intel Pin tools for binary instrumentation</title>
		<link>https://labs.portcullis.co.uk/blog/using-intel-pin-tools-for-binary-instrumentation/</link>
		<comments>https://labs.portcullis.co.uk/blog/using-intel-pin-tools-for-binary-instrumentation/#comments</comments>
		<pubDate>Tue, 04 Nov 2014 16:03:01 +0000</pubDate>
		<dc:creator><![CDATA[BRC]]></dc:creator>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[analysis]]></category>
		<category><![CDATA[auditing]]></category>
		<category><![CDATA[binary]]></category>
		<category><![CDATA[reversing]]></category>

		<guid isPermaLink="false">https://labs.portcullis.co.uk/?p=4131</guid>
		<description><![CDATA[<p>This article is continues the topic on dynamic instrumentation that it was presented before in a previous article. Yama LSM In this post, the basics of coding Intel Pin tools will be presented, but before we discuss this, you should be aware that a Linux Security Module exists that prevents binary instrumentation by default. Yama [&#8230;]</p><p>The post <a href="https://labs.portcullis.co.uk/blog/using-intel-pin-tools-for-binary-instrumentation/">Using Intel Pin tools for binary instrumentation</a> appeared first on <a href="https://labs.portcullis.co.uk">Portcullis Labs</a>.</p>]]></description>
				<content:encoded><![CDATA[<p>This article is continues the topic on <a title="dynamic instrumentation" href="http://en.wikipedia.org/wiki/Instrumentation_%28computer_programming%29">dynamic instrumentation</a> that it was presented before in a <a title="previous article" href="https://labs.portcullis.co.uk/blog/an-introduction-to-binary-dynamic-analysis">previous article</a>.<span id="more-4131"></span></p>
<h2>Yama LSM</h2>
<p>In this post, the basics of coding <a title="Intel Pin" href="http://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool">Intel Pin</a> tools will be presented, but before we discuss this, you should be aware that a <a title="Linux Security Module" href="http://en.wikipedia.org/wiki/Linux_Security_Modules">Linux Security Module</a> exists that prevents binary instrumentation by default. <a title="Yama" href="https://www.kernel.org/doc/Documentation/security/Yama.txt">Yama</a> is a Linux Security Module that collects a number of system-wide <a title="DAC" href="http://en.wikipedia.org/wiki/Discretionary_access_control">DAC</a> security protections that are not handled by the core kernel itself. Yama is controlled using sysctl. A description of some of the possible values for /proc/sys/kernel/yama/ptrace_scope is provided below:</p>
<ul>
<li>0 =&gt; Classic ptrace: a process can PTRACE_ATTACH to any other process running under the same uid, as long as it is dumpable.</li>
<li>1 =&gt; Restricted ptrace: a process can only PTRACE_ATTACH only its descendants although an inferior can call prctl(PR_SET_PTRACER, debugger, &#8230;) to allow the debugger to call PTRACE_ATTACH.</li>
<li>2 =&gt; Admin-only attach: only processes with CAP_SYS_PTRACE may use ptrace with PTRACE_ATTACH</li>
<li>3 =&gt; No attach: no processes may use ptrace with PTRACE_ATTACH nor via PTRACE_TRACEME.</li>
</ul>
<p>For detailed information, visit the Linux kernel documentation about <a title="Yama" href="https://www.kernel.org/doc/Documentation/security/Yama.txt">Yama</a>.</p>
<p>Continuing with the Pin topic, it should be noted that if a Pin tool is executed without setting /proc/sys/kernel/yama/ptrace_scope to 0, the following message will appear:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ ../pin/pin -t obj-intel64/check_pc_sections.so -- /bin/ls
E:Attach to pid 9495 failed.
E:  The Operating System configuration prevents Pin from using the default (parent) injection mode.
E:  To resolve this, either execute the following (as root):
E:  $ echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope
E:  Or use the &quot;-injection child&quot; option.
E:  For more information, regarding child injection, see Injection section in the Pin User Manual.
E:
Terminado (killed)
</pre>
<p>To allow debugging of inferior processes the value of /proc/sys/kernel/yama/ptrace_scope needs to be changed using sysctl:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
# sysctl kernel.yama.ptrace_scope=0
kernel.yama.ptrace_scope = 0
</pre>
<h3>Pin tools</h3>
<p>The Pin tools are the tools created using Pin and used to perform program analysis on user space. Pin tools that perform the binary instrumentation have two key components:</p>
<ol>
<li>The instrumentation callback routine: a mechanism that decides if and where to inject calls to analysis functions; and</li>
<li>The analysis function: code to execute at insertion points.</li>
</ol>
<p>Note that the Pin tools are able to control a program starting with the very first instruction, meaning that it is possible even to inspect the linker&#8217;s code of a binary loading shared libraries. This could be utilised to perform run-time bug hunting in the operating system linker. Also, when programming Pin tools, it should be kept in mind that as the <a title="Pin documentation" href="http://software.intel.com/sites/landingpage/pintool/docs/58423/Pin/html/index.html#Pin">Pin documentation</a> specifies, it is more important to tune the analysis code than the instrumentation code. This is because the instrumentation is executed once, but analysis code is called many times.</p>
<h2>Executable Images and Sections</h2>
<p>Pin provides access to the binary&#8217;s images and image sections using linked lists. Those lists can be traversed using the API calls APP_ImgHead(), App_ImgTail(), IMG_Valid(IMG x), IMG_Next(IMG x) and IMG_Previous(IMG x); additionally, a number a API functions exist for accessing image properties such as name, size, type, start address, etc. A detailed view of the image API can be examined in the <a title="image documentation" href="http://software.intel.com/sites/landingpage/pintool/docs/58423/Pin/html/group__IMG__BASIC__API.html">image API documentation</a>.</p>
<p>The image sections have the equivalent API functions to traverse the linked list: IMG_SecHead(IMG x),IMG_SecTail(IMG x), SEC_Valid(sec x), SEC_Prev(sec x), SEC_Next(sec x), SEC_Address (SEC sec), SEC_Valid (SEC x), etc. The complete list can be found in the <a title="section API documentation" href="http://software.intel.com/sites/landingpage/pintool/docs/58423/Pin/html/group__SEC__BASIC__API.html">section API documentation</a>.</p>
<p>To illustrate the usage of the image and section API an example is provided:</p>
<pre class="brush: cpp; title: ; notranslate">
#include &quot;pin.H&quot;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string.h&gt;

// =====================================================================
// Usage
// =====================================================================

INT32 Usage()
{
    cerr &lt;&lt; &quot;[*] This Pin tool prints the images and section names of a binary when loading&quot; &lt;&lt; endl;
    return -1;
}

// =====================================================================
// Analysis routines
// =====================================================================

// Prints image and section name, type and address
VOID loadImageSec(IMG img, VOID *v)
{
    UINT64 sec_cont = 0;
    string img_type;
    string sec_type;

    switch (IMG_Type(img)){
        case IMG_TYPE_STATIC:
            img_type = &quot;static&quot;;
            break;
        case IMG_TYPE_SHARED:
            img_type = &quot;shared&quot;;
            break;
        case IMG_TYPE_SHAREDLIB:
            img_type = &quot;shared library&quot;;
            break;
        case IMG_TYPE_RELOCATABLE:
            img_type = &quot;relocatable&quot;;
            break;
        default:
            img_type = &quot;unknown&quot;;
    }

    cout &lt;&lt; &quot;[*] Loading image &quot; &lt;&lt; IMG_Name(img).c_str();
    cout &lt;&lt; &quot; @ &quot; &lt;&lt; StringFromAddrint(IMG_StartAddress(img));
    cout &lt;&lt; &quot; type &quot; &lt;&lt; img_type &lt;&lt; endl;

    for (SEC sec=IMG_SecHead(img); SEC_Valid(sec); sec=SEC_Next(sec)) {
        if (strcmp(SEC_Name(sec).c_str(),&quot;&quot;)) {

            switch (SEC_Type(sec)){
                case SEC_TYPE_REGREL:
                    sec_type = &quot;relocations&quot;;
                    break;
                case SEC_TYPE_DYNREL:
                    sec_type = &quot;dynamic relocations&quot;;
                    break;
                case SEC_TYPE_EXEC:
                    sec_type = &quot;code&quot;;
                    break;
                case SEC_TYPE_DATA:
                    sec_type = &quot;initialized data&quot;;
                    break;
                case SEC_TYPE_BSS:
                    sec_type = &quot;unitialized data&quot;;
                    break;
                case SEC_TYPE_LOOS:
                    sec_type = &quot;operating system specific&quot;;
                    break;
                case SEC_TYPE_USER:
                    sec_type = &quot;user application specific&quot;;
                    break;
                default:
                    sec_type = &quot;unknown&quot;;
            }

            cout &lt;&lt; &quot;\t =&gt; Loading section &quot; &lt;&lt; SEC_Name(sec).c_str();
            cout &lt;&lt; &quot; @ &quot; &lt;&lt; StringFromAddrint(SEC_Address(sec));
            cout &lt;&lt; &quot; type &quot; &lt;&lt; sec_type &lt;&lt; endl;

            sec_cont++;
        }
    }

    cout &lt;&lt; &quot;[*] Done loading &quot; &lt;&lt; IMG_Name(img).c_str() &lt;&lt; &quot;: &quot; &lt;&lt; sec_cont &lt;&lt; &quot; sections&quot; &lt;&lt; endl;

}

// =====================================================================
// Main
// =====================================================================

int main(int argc, char *argv[])
{

    if(PIN_Init(argc,argv)) {
        return Usage();
    }

    cout &lt;&lt; &quot;[*] Executing Pin tool&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;[*] Adding instrumentation functions&quot; &lt;&lt; endl;
    IMG_AddInstrumentFunction(loadImageSec, 0);

    cout &lt;&lt; &quot;[*] Executing target program&quot; &lt;&lt; endl;
    PIN_StartProgram();

    return 0;
}
// EOF
</pre>
<p>To compile the Pin tool, save the code as load_bin_img_sec.cpp and execute the following cmd line on the custom development directory as explained in the <a title="previous article" href="https://labs.portcullis.co.uk/blog/an-introduction-to-binary-dynamic-analysis">previous article</a>:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
~/mytools $ ./build.sh
[*] Building load_bin_img_sec.cpp
g++ -DBIGARRAY_MULTIPLIER=1 -DUSING_XED -Wall -Werror -Wno-unknown-pragmas -fno-stack-protector -DTARGET_IA32E -DHOST_IA32E -fPIC -DTARGET_LINUX  -I../pin/source/include/pin -I../pin/source/include/pin/gen -I../pin/extras/components/include -I../pin/extras/xed2-intel64/include -I../pin/source/tools/InstLib -O3 -fomit-frame-pointer -fno-strict-aliasing   -c -o obj-intel64/load_bin_img_sec.o load_bin_img_sec.cpp
g++ -shared -Wl,--hash-style=sysv -Wl,-Bsymbolic -Wl,--version-script=../pin/source/include/pin/pintool.ver    -o obj-intel64/load_bin_img_sec.so obj-intel64/load_bin_img_sec.o  -L../pin/intel64/lib -L../pin/intel64/lib-ext -L../pin/intel64/runtime/glibc -L../pin/extras/xed2-intel64/lib -lpin -lxed -ldwarf -lelf -ldl
[*] Exec ../pin/pin -t obj-intel64/load_bin_img_sec.so -- &lt;program&gt;
</pre>
<p>The binary /bin/ls is taken as example target binary for the execution of compiled Pin tool:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
~/mytools $ ../pin/pin -t obj-intel64/load_bin_img_sec.so -- /bin/ls /tmp/
[*] Executing PIN tool
[*] Adding instrumentation functions
[*] Executing target program
[*] Loading image /usr/bin/ls @ 0x00007f55b8798000 type shared
	 =&gt; Loading section .interp @ 0x0000000000400238 type initialized data
	 =&gt; Loading section .note.ABI-tag @ 0x0000000000400254 type initialized data
	 =&gt; Loading section .note.gnu.build-id @ 0x0000000000400274 type initialized data
	 =&gt; Loading section .dynsym @ 0x0000000000400350 type unknown
	 =&gt; Loading section .dynstr @ 0x0000000000400f50 type unknown
	 =&gt; Loading section .rela.dyn @ 0x0000000000401670 type relocations
	 =&gt; Loading section .rela.plt @ 0x0000000000401718 type relocations
	 =&gt; Loading section .init @ 0x0000000000402180 type code
	 =&gt; Loading section .plt @ 0x00000000004021a0 type code
	 =&gt; Loading section .text @ 0x00000000004028a0 type code
	 =&gt; Loading section .fini @ 0x0000000000411d4c type code
	 =&gt; Loading section .rodata @ 0x0000000000411d60 type initialized data
	 =&gt; Loading section .eh_frame_hdr @ 0x0000000000416e7c type initialized data
	 =&gt; Loading section .eh_frame @ 0x0000000000417588 type initialized data
	 =&gt; Loading section .init_array @ 0x0000000000619df0 type initialized data
	 =&gt; Loading section .fini_array @ 0x0000000000619df8 type initialized data
	 =&gt; Loading section .jcr @ 0x0000000000619e00 type initialized data
	 =&gt; Loading section .dynamic @ 0x0000000000619e08 type unknown
	 =&gt; Loading section .got @ 0x0000000000619ff8 type unknown
	 =&gt; Loading section .got.plt @ 0x000000000061a000 type initialized data
	 =&gt; Loading section .data @ 0x000000000061a3a0 type initialized data
	 =&gt; Loading section .bss @ 0x000000000061a600 type unitialized data
	 =&gt; Loading section .comment @ 0x0000000000000000 type unknown
	 =&gt; Loading section .shstrtab @ 0x0000000000000000 type unknown
[*] Done loading /usr/bin/ls: 24 sections
[*] Loading image /lib64/ld-linux-x86-64.so.2 @ 0x00007f55b8788000 type shared library
	 =&gt; Loading section .note.gnu.build-id @ 0x00007f55cb9201c8 type initialized data
	 =&gt; Loading section .hash @ 0x00007f55cb9201f0 type unknown
	 =&gt; Loading section .dynsym @ 0x00007f55cb920470 type unknown
	 =&gt; Loading section .dynstr @ 0x00007f55cb920710 type unknown
	 =&gt; Loading section .rela.dyn @ 0x00007f55cb920988 type relocations
	 =&gt; Loading section .rela.plt @ 0x00007f55cb920ac0 type relocations
	 =&gt; Loading section .plt @ 0x00007f55cb920b50 type code
	 =&gt; Loading section .text @ 0x00007f55cb920bc0 type code
	 =&gt; Loading section .rodata @ 0x00007f55cb939100 type initialized data
	 =&gt; Loading section .eh_frame_hdr @ 0x00007f55cb93d300 type initialized data
	 =&gt; Loading section .eh_frame @ 0x00007f55cb93d950 type initialized data
	 =&gt; Loading section .data.rel.ro @ 0x00007f55cbb40ba0 type initialized data
	 =&gt; Loading section .dynamic @ 0x00007f55cbb40e10 type unknown
	 =&gt; Loading section .got @ 0x00007f55cbb40fa0 type unknown
	 =&gt; Loading section .data @ 0x00007f55cbb41000 type initialized data
	 =&gt; Loading section .bss @ 0x00007f55cbb41fa0 type unitialized data
	 =&gt; Loading section .comment @ 0x0000000000000000 type unknown
	 =&gt; Loading section .shstrtab @ 0x0000000000000000 type unknown
	 =&gt; Loading section .symtab @ 0x0000000000000000 type unknown
	 =&gt; Loading section .strtab @ 0x0000000000000000 type unknown
[*] Done loading /lib64/ld-linux-x86-64.so.2: 20 sections
[*] Loading image /usr/lib/libcap.so.2 @ 0x00007f55b7c50000 type shared library
	 =&gt; Loading section .note.gnu.build-id @ 0x00007f55b84a8190 type initialized data
	 =&gt; Loading section .dynsym @ 0x00007f55b84a82b0 type unknown
	 =&gt; Loading section .dynstr @ 0x00007f55b84a8898 type unknown
	 =&gt; Loading section .rela.dyn @ 0x00007f55b84a8c30 type relocations
	 =&gt; Loading section .rela.plt @ 0x00007f55b84a9080 type relocations
	 =&gt; Loading section .init @ 0x00007f55b84a9350 type code
	 =&gt; Loading section .plt @ 0x00007f55b84a9370 type code
	 =&gt; Loading section .text @ 0x00007f55b84a9560 type code
	 =&gt; Loading section .fini @ 0x00007f55b84aac54 type code
	 =&gt; Loading section .rodata @ 0x00007f55b84aac60 type initialized data
	 =&gt; Loading section .eh_frame_hdr @ 0x00007f55b84aaf48 type initialized data
	 =&gt; Loading section .eh_frame @ 0x00007f55b84ab060 type initialized data
	 =&gt; Loading section .init_array @ 0x00007f55b86ab648 type initialized data
	 =&gt; Loading section .fini_array @ 0x00007f55b86ab650 type initialized data
	 =&gt; Loading section .jcr @ 0x00007f55b86ab658 type initialized data
	 =&gt; Loading section .dynamic @ 0x00007f55b86ab660 type unknown
	 =&gt; Loading section .got @ 0x00007f55b86ab840 type unknown
	 =&gt; Loading section .got.plt @ 0x00007f55b86ab870 type initialized data
	 =&gt; Loading section .data @ 0x00007f55b86ab980 type initialized data
	 =&gt; Loading section .bss @ 0x00007f55b86abac8 type unitialized data
	 =&gt; Loading section .comment @ 0x0000000000000000 type unknown
	 =&gt; Loading section .shstrtab @ 0x0000000000000000 type unknown
[*] Done loading /usr/lib/libcap.so.2: 22 sections
[*] Loading image /usr/lib/libacl.so.1 @ 0x00007f55b7c48000 type shared library
	 =&gt; Loading section .note.gnu.build-id @ 0x00007f55b82881c8 type initialized data
	 =&gt; Loading section .dynsym @ 0x00007f55b82884f8 type unknown
	 =&gt; Loading section .dynstr @ 0x00007f55b8288ed0 type unknown
	 =&gt; Loading section .rela.dyn @ 0x00007f55b8289580 type relocations
	 =&gt; Loading section .rela.plt @ 0x00007f55b8289700 type relocations
	 =&gt; Loading section .init @ 0x00007f55b8289cb8 type code
	 =&gt; Loading section .plt @ 0x00007f55b8289ce0 type code
	 =&gt; Loading section .text @ 0x00007f55b828a0c0 type code
	 =&gt; Loading section .fini @ 0x00007f55b828dea4 type code
	 =&gt; Loading section .rodata @ 0x00007f55b828deb0 type initialized data
	 =&gt; Loading section .eh_frame_hdr @ 0x00007f55b828e154 type initialized data
	 =&gt; Loading section .eh_frame @ 0x00007f55b828e380 type initialized data
	 =&gt; Loading section .init_array @ 0x00007f55b848fd98 type initialized data
	 =&gt; Loading section .fini_array @ 0x00007f55b848fda0 type initialized data
	 =&gt; Loading section .jcr @ 0x00007f55b848fda8 type initialized data
	 =&gt; Loading section .dynamic @ 0x00007f55b848fdb0 type unknown
	 =&gt; Loading section .got @ 0x00007f55b848ffb0 type unknown
	 =&gt; Loading section .got.plt @ 0x00007f55b8490000 type initialized data
	 =&gt; Loading section .data @ 0x00007f55b8490200 type initialized data
	 =&gt; Loading section .bss @ 0x00007f55b8490270 type unitialized data
	 =&gt; Loading section .comment @ 0x0000000000000000 type unknown
	 =&gt; Loading section .shstrtab @ 0x0000000000000000 type unknown
[*] Done loading /usr/lib/libacl.so.1: 22 sections
[*] Loading image /usr/lib/libc.so.6 @ 0x00007f55b7a68000 type shared library
	 =&gt; Loading section .note.gnu.build-id @ 0x00007f55b7ee0270 type initialized data
	 =&gt; Loading section .note.ABI-tag @ 0x00007f55b7ee0294 type initialized data
	 =&gt; Loading section .dynsym @ 0x00007f55b7ee3d28 type unknown
	 =&gt; Loading section .dynstr @ 0x00007f55b7ef0d78 type unknown
	 =&gt; Loading section .rela.dyn @ 0x00007f55b7ef7b10 type relocations
	 =&gt; Loading section .rela.plt @ 0x00007f55b7eff298 type relocations
	 =&gt; Loading section .plt @ 0x00007f55b7eff3c0 type code
	 =&gt; Loading section .text @ 0x00007f55b7eff490 type code
	 =&gt; Loading section __libc_freeres_fn @ 0x00007f55b8028bc0 type code
	 =&gt; Loading section __libc_thread_freeres_fn @ 0x00007f55b80299b0 type code
	 =&gt; Loading section .rodata @ 0x00007f55b8029ba0 type initialized data
	 =&gt; Loading section .interp @ 0x00007f55b804b790 type initialized data
	 =&gt; Loading section .eh_frame_hdr @ 0x00007f55b804b7b0 type initialized data
	 =&gt; Loading section .eh_frame @ 0x00007f55b80521e0 type initialized data
	 =&gt; Loading section .gcc_except_table @ 0x00007f55b807a954 type initialized data
	 =&gt; Loading section .hash @ 0x00007f55b807ad18 type unknown
	 =&gt; Loading section .tdata @ 0x00007f55b827e718 type initialized data
	 =&gt; Loading section .tbss @ 0x00007f55b827e728 type unitialized data
	 =&gt; Loading section .init_array @ 0x00007f55b827e728 type initialized data
	 =&gt; Loading section __libc_subfreeres @ 0x00007f55b827e730 type initialized data
	 =&gt; Loading section __libc_atexit @ 0x00007f55b827e820 type initialized data
	 =&gt; Loading section __libc_thread_subfreeres @ 0x00007f55b827e828 type initialized data
	 =&gt; Loading section .data.rel.ro @ 0x00007f55b827e860 type initialized data
	 =&gt; Loading section .dynamic @ 0x00007f55b8281b80 type unknown
	 =&gt; Loading section .got @ 0x00007f55b8281d70 type unknown
	 =&gt; Loading section .got.plt @ 0x00007f55b8282000 type initialized data
	 =&gt; Loading section .data @ 0x00007f55b8282080 type initialized data
	 =&gt; Loading section .bss @ 0x00007f55b8283740 type unitialized data
	 =&gt; Loading section .comment @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.sigstack @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.sigreturn @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.siggetmask @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.tmpnam @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.tmpnam_r @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.tempnam @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.sys_errlist @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.sys_nerr @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.gets @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.getpw @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.re_max_failures @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.lchmod @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.getwd @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.sstk @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.revoke @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.mktemp @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.gtty @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.stty @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.chflags @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.fchflags @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.bdflush @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.__gets_chk @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.inet6_option_space @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.inet6_option_init @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.inet6_option_append @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.inet6_option_alloc @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.inet6_option_next @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.inet6_option_find @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.getmsg @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.putmsg @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.fattach @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.fdetach @ 0x0000000000000000 type unknown
	 =&gt; Loading section .gnu.warning.setlogin @ 0x0000000000000000 type unknown
	 =&gt; Loading section .shstrtab @ 0x0000000000000000 type unknown
	 =&gt; Loading section .symtab @ 0x0000000000000000 type unknown
	 =&gt; Loading section .strtab @ 0x0000000000000000 type unknown
[*] Done loading /usr/lib/libc.so.6: 65 sections
[*] Loading image /usr/lib/libattr.so.1 @ 0x00007f55b7c50000 type shared library
	 =&gt; Loading section .note.gnu.build-id @ 0x00007f55b7cd81c8 type initialized data
	 =&gt; Loading section .dynsym @ 0x00007f55b7cd8378 type unknown
	 =&gt; Loading section .dynstr @ 0x00007f55b7cd8930 type unknown
	 =&gt; Loading section .rela.dyn @ 0x00007f55b7cd8ce8 type relocations
	 =&gt; Loading section .rela.plt @ 0x00007f55b7cd8dc0 type relocations
	 =&gt; Loading section .init @ 0x00007f55b7cd9198 type code
	 =&gt; Loading section .plt @ 0x00007f55b7cd91c0 type code
	 =&gt; Loading section .text @ 0x00007f55b7cd9460 type code
	 =&gt; Loading section .fini @ 0x00007f55b7cdb4ac type code
	 =&gt; Loading section .rodata @ 0x00007f55b7cdb4b5 type initialized data
	 =&gt; Loading section .eh_frame_hdr @ 0x00007f55b7cdb56c type initialized data
	 =&gt; Loading section .eh_frame @ 0x00007f55b7cdb668 type initialized data
	 =&gt; Loading section .init_array @ 0x00007f55b7edbdc8 type initialized data
	 =&gt; Loading section .fini_array @ 0x00007f55b7edbdd0 type initialized data
	 =&gt; Loading section .jcr @ 0x00007f55b7edbdd8 type initialized data
	 =&gt; Loading section .dynamic @ 0x00007f55b7edbde0 type unknown
	 =&gt; Loading section .got @ 0x00007f55b7edbfd0 type unknown
	 =&gt; Loading section .got.plt @ 0x00007f55b7edc000 type initialized data
	 =&gt; Loading section .data @ 0x00007f55b7edc160 type initialized data
	 =&gt; Loading section .bss @ 0x00007f55b7edc168 type unitialized data
	 =&gt; Loading section .comment @ 0x0000000000000000 type unknown
	 =&gt; Loading section .shstrtab @ 0x0000000000000000 type unknown
[*] Done loading /usr/lib/libattr.so.1: 22 sections
PKGBUILD      plugtmp  test-kernel-security.py  yaourt-tmp-user
~/mytools $
</pre>
<p>As you can see, Intel Pin tool provides a rich API to inspect the different parts of a binary, including sections, images, functions, registers, etc, which could help security researchers to detect an anomalies such us:</p>
<ul>
<li>Whether the instruction pointer points to a memory address outside the code segment?</li>
<li>Are parts of the memory getting overwritten by user input?</li>
<li>Whether there are too many RETs getting executed within a small part of the code</li>
</ul>
<p>The post <a href="https://labs.portcullis.co.uk/blog/using-intel-pin-tools-for-binary-instrumentation/">Using Intel Pin tools for binary instrumentation</a> appeared first on <a href="https://labs.portcullis.co.uk">Portcullis Labs</a>.</p>]]></content:encoded>
			<wfw:commentRss>https://labs.portcullis.co.uk/blog/using-intel-pin-tools-for-binary-instrumentation/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Vanilla good security practice vs. BadUSB</title>
		<link>https://labs.portcullis.co.uk/blog/vanilla-good-security-practice-vs-badusb/</link>
		<comments>https://labs.portcullis.co.uk/blog/vanilla-good-security-practice-vs-badusb/#comments</comments>
		<pubDate>Thu, 09 Oct 2014 16:18:10 +0000</pubDate>
		<dc:creator><![CDATA[BRC]]></dc:creator>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[analysis]]></category>
		<category><![CDATA[hardhack]]></category>

		<guid isPermaLink="false">https://labs.portcullis.co.uk/?p=4718</guid>
		<description><![CDATA[<p>This post discusses the BadUSB research published by Karsten Nohl recently at Black Hat. You might want to check out the slides and/or video before reading on. It&#8217;s also worth noting that more recently Adam Caudill and Brandon Wilson figured out how to implement the attacks and have published proof-of-concept code which makes the challenges [&#8230;]</p><p>The post <a href="https://labs.portcullis.co.uk/blog/vanilla-good-security-practice-vs-badusb/">Vanilla good security practice vs. BadUSB</a> appeared first on <a href="https://labs.portcullis.co.uk">Portcullis Labs</a>.</p>]]></description>
				<content:encoded><![CDATA[<p>This post discusses the <a title="BadUSB research" href="https://srlabs.de/badusb/">BadUSB research</a> published by Karsten Nohl recently at <a title="Black Hat" href="https://www.blackhat.com/us-14/briefings.html#Nohl">Black Hat</a>. You might want to check out the <a title="slides" href="https://srlabs.de/blog/wp-content/uploads/2014/07/SRLabs-BadUSB-BlackHat-v1.pdf">slides</a> and/or <a title="video" href="https://www.youtube.com/watch?v=nuruzFqMgIw">video</a> before reading on.<span id="more-4718"></span></p>
<p>It&#8217;s also worth noting that more recently Adam Caudill and Brandon Wilson figured out how to implement the attacks and have published <a title="proof-of-concept code" href="https://github.com/adamcaudill/Psychson">proof-of-concept code</a> which makes the challenges of defending against the original research seem somewhat more acute.</p>
<p>The challenges of defending against the attacks presented in the BadUSB talk largely break down into two areas:</p>
<ul>
<li>Defending USB devices from tampering</li>
<li>Defending workstations and servers from bad USB devices</li>
</ul>
<p>In this post only the latter will be discussed. However, with regard to the former, applaud the work done by Karsten Nohl. You should now be pretty wary about all your USB devices being subverted by attackers. Next time you use a keyboard or mouse that&#8217;s left lying around, you should be thinking about this research. Next time someone hands a USB stick to you, you should think if it has been reprogrammed to be a BadUSB stick. A word to our colleagues in the industry, we look forward to hearing from the USB device manufacturers about devices that can&#8217;t be tampered with in the way the researchers describe.</p>
<p>In the remainder of this post it has been considered how computer systems can defend or mitigate against malicious USB devices using vanilla good security practice and to what extent this is sufficient. It should be understood that this wasn&#8217;t the main crux of the research done, but as a security industry member, you should admit that it is quite interesting to consider the different USB-based attack vectors that could be used in order to gain access to computer systems as well which could be used to access a security researcher&#8217;s machine.</p>
<h2>Defending workstations and servers from bad USB devices</h2>
<p>If someone can plug a USB device into a workstation/laptop/server, there&#8217;s a chance that the employed USB device can subvert its normal workflow in a very clever way. The researchers Karsten Nohl and Jakob Lell presented some example attacks that were pretty innovative. Some they&#8217;ve proved work, some are just ideas for further development in this area.</p>
<p>The following examples can be summarised to illustrate some of the ideas outlined from their research:</p>
<ul>
<li>If the USB device pretends to be a USB network interface and abuses DHCP to set a default route or a target DNS server, network traffic can be diverted to the bad guys</li>
<li>If the USB device pretends to be a keyboard it can start sending commands to a computer controlled by an attacker</li>
<li>If the USB device is left connected when the computer reboots, the computer could be attacked as it boots. The target machine may boot off it &#8211; and if the USB device is cleverly configured, the user or system administrator might not be able to detect that the device is capable of being a boot disk. Alternatively, the device might send keystrokes to modify the boot order or even modify the BIOS configuration</li>
<li>If the USB device pretends to be a USB display, it might be able to scrape what&#8217;s on a computer screen and make it available to attackers</li>
</ul>
<p>Some of the attacks weren&#8217;t new (e.g. the <a title="Rubber Ducky" href="https://hakshop.myshopify.com/products/usb-rubber-ducky-deluxe">Rubber Ducky</a> has been pretending to be a keyboard for some time), but presenting these ideas together made a pretty compelling case that USB is bad.</p>
<p>Should we really be worried about protecting our computers from bad USB devices?</p>
<p>In short, yes. In some attack scenarios, these ideas really are quite worrying and and they&#8217;re pretty hard to fix or mitigate, but not in all scenarios! Some of the attacks can be mitigated fairly easily by following existing vanilla good security practice which can be found below.</p>
<h3>Defending the boot process</h3>
<p>Firstly we&#8217;ll examine how to protect the boot process against malicious USB devices using vanilla good security practice.</p>
<ul>
<li>Configure the BIOS of computers to only boot from the internal hard disk</li>
</ul>
<p>This should stop attackers booting off USB devices. But the bad USB device might reconfigure your BIOS to boot off some other device &#8211; specifically if it sends keystrokes during system boot.</p>
<ul>
<li>Set a BIOS password to prevent modification of BIOS settings</li>
</ul>
<p>This should make it pretty hard for anyone to boot off a USB device whether or not they are using a bad USB device. So, in short I don&#8217;t think it&#8217;s necessary to worry about your users being tricked into booting off malicious devices in this context. It&#8217;s fairly simple to secure the boot process against the attack scenario described.</p>
<h3>Defending servers</h3>
<p>Clearly servers are key assets and physical security controls probably provide a good level of protection already. In my experience, server rooms are access controlled &#8211; so relatively few people are allowed in and those who are have their identities checked, an access log is maintained and they might even be vetted to a certain extent first. Once they&#8217;re in, their access is (sometimes at least) restricted to only the racks they need to work in. The racks prevent the poking of usb devices into other people&#8217;s servers. However, everything in the exposed racks is certainly vulnerable to potential USB attacks.</p>
<p>Pragmatically, if the attacker has physical access to your server, you probably have bigger problems than a USB-based attack.</p>
<ul>
<li>How to protect against bad USB devices that pretend to be keyboards?</li>
</ul>
<p>Lock your laptop/workstation when it&#8217;s not in use. Then all the fake keyboard can do is try to log in. If the the bad keyboard doesn&#8217;t know your password, you&#8217;re reasonably safe. It could conceivably lock out your account or other AD users, but that&#8217;s not an awfully compelling attack.</p>
<ul>
<li>How to protect laptops when they&#8217;re not being used?</li>
</ul>
<p>Use a full disk encryption solution and make sure that laptops are powered down when not in use. This will make sure that a password is required to boot/resume the OS. Some of the USB attacks discussed are effective even with the host booted and the screen locked. Specifically the USB network device intercepting your traffic. Full disk encryption (FDE) is pretty essential anyway for laptops in most companies. To get the full benefit from FDE, hosts should be powered down when not in use, so this lines up with our requirement of keeping hosts protected from USB attacks by not leaving hosts unnecessarily booted and therefore exposed to attack.</p>
<ul>
<li>How to protect workstations from fake keyboards?</li>
</ul>
<h3>Locking down the desktop environment</h3>
<p>This is fairly difficult to do well, but good security practice can help to mitigate. Using lockdown technologies like group policy, SRP, app locker and kiosk software, devices can be restricted to only run the application they need to run. Clearly this is appropriate in some environments, but not in others. Corporate workstations can be and sometimes are locked down &#8211; you can&#8217;t run any old program, you can&#8217;t browse the C:\ drive, you can&#8217;t Start|Run or WindowsKey+R.</p>
<p>How does this help? Well, the bad keyboard is probably going to send a series of keystrokes in order to download and run some malware. If a user&#8217;s login session has been restricted, the bad keyboard&#8217;s attempt to use Windows-key+R or launch IE may not work at all.</p>
<ul>
<li>Anti-Virus, Content Checkers</li>
</ul>
<p>&#8230;and if the attacker&#8217;s going to be downloading malware, using a content checker for web traffic and having AV installed might (and I stress might) save the day.</p>
<ul>
<li>USB Lockdown</li>
</ul>
<p>This will be an interesting area to watch. Will there be a rush to buy third party software to block certain types / classes of USB device? Some vendors are claiming to protect against BadUSB attacks (but I haven&#8217;t tested their software, so am not linking to them from this post). Google for terms like &#8220;usb endpoint device control&#8221;, &#8220;usb endpoint protection&#8221; and possibly adding the term &#8220;badusb&#8221; should lead you towards what the market&#8217;s currently offering.</p>
<p>The idea of some sort of USB Firewall is an attractive one, particularly one that ships as part of the OS. It remains to be seen how well this could be implemented, how easily it could be bypassed and to what extent is impairs business operations.</p>
<p>As a closing thought, if you haven&#8217;t considered the perils of uncontrolled access to Firewire ports and PCI Express slots, maybe worry about those first.</p>
<h2>Mitigations</h2>
<h3>Windows</h3>
<p>Windows can help to mitigate this issue by using <a title="GPO" href="http://en.wikipedia.org/wiki/Group_Policy">GPO</a> as IronGeek described in the following post <a title="Plug and Pray Malicious USB devies" href="http://www.irongeek.com/i.php?page=security%2Fplug-and-prey-malicious-usb-devices">Plug and Pray Malicious USB devices</a></p>
<h3>GNU/Linux: udev rules</h3>
<p>The BadUSB attack bases itself on the fact that computers allow and enable HID devices on all usb ports. On Linux, a temporarily fix could be employed using udev to temporarily disable the addition of new HID devices as described on StackExchange by user10008 . For preparation, create a file /etc/udev/rules.d/10-usbblock.rules with the content:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
    #ACTION==&quot;add&quot;, ATTR{bInterfaceClass}==&quot;03&quot; RUN+=&quot;/bin/sh -c 'echo 0 &gt;/sys$DEVPATH/../authorized'&quot;
</pre>
<p>To block other classes, It is needed to look up the class number and substitute copy the line, and change the class. To block all new HID devices the following command can be employed:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
    sed -i 's/#//' /etc/udev/rules.d/10-usbblock.rules; udevadm control --reload-rules
</pre>
<p>To unblock all new HID devices the following command can be employed:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
    sed -i 's/^/#/' /etc/udev/rules.d/10-usbblock.rules; udevadm control --reload-rules
</pre>
<p>Note that before powering off the system, It is required to remove the block as udev&#8217;s setting are persistent, and thusly legitimate HID devices would be rejected on boot.</p>
<h3>FreeBSD</h3>
<p>The people from FreeBSD already submitted a patch to remediate this issue. The patch files can be examined at <a title="FreeBSD SVN web" href="https://svnweb.freebsd.org/changeset/base/272733">FreeBSD SVN web</a>. This patch adds some system tunables that can be controlled by the well known sysctl.</p>
<pre class="brush: plain; gutter: false; title: ; notranslate">
hw.usb.disable_enumeration: 0
dev.uhub.0.disable_enumeration: 0
dev.uhub.1.disable_enumeration: 0
[...]
</pre>
<p>It should be noted that these system tunables can be also set through /boot/loader.conf</p>
<h2>Conclusion</h2>
<p>So with these potential mitigations in mind, let&#8217;s restate the attacks above and review how concerned we should be:</p>
<p>It could pretend to be a USB network interface and abuse DHCP to set your default route or your DNS server. Either way, you could end up with network traffic being diverted to the bad guys.</p>
<p>I am pretty worried about this attack. But it only works when my computer is booted. It even works when my screen is locked. The attacker obviously requires physical access, but that&#8217;s entirely possible in a corporate environment.</p>
<p>If the USB device pretends to be a keyboard it can start sending commands to your computer &#8211; as if you typed them.</p>
<p>This one is worth bearing in mind. It&#8217;s possible to mitigate to an extent if you prevent users from running unnecessary programs. It remains possible that your bad USB device might suddenly become a keyboard when you&#8217;re least expecting it.</p>
<p>Limiting the amount of time your USB device is connected narrows the attack window. But that doesn&#8217;t really fix the problem. Your keyboard and mouse are plugged in all the time, right? And are you sure they haven&#8217;t been tampered with?</p>
<p>If the USB device is left connected when the computer reboots, you computer could be attacked as it boots. The computer may boot off it &#8211; and if the USB device is cleverly configured, you might not be able to tell the device is capable of being a boot disk. Alternatively, the device might send keystrokes to modify the boot order or even modify the BIOS.</p>
<p>I&#8217;m not worried about this really. It&#8217;s possible to secure the boot process against these attacks.</p>
<p>If the USB device pretends to be a USB display, it might be able to scrape what&#8217;s on your screen and make it available to the bad guys.</p>
<p>I&#8217;m fairly worried about this one. Obviously my screen can&#8217;t be locked for this attack &#8211; if it were the attacker doesn&#8217;t really win by screenshotting the log in screen. However, if my screen is unlocked &#8211; maybe someone passes me a USB stick, this could really work.</p>
<p>The post <a href="https://labs.portcullis.co.uk/blog/vanilla-good-security-practice-vs-badusb/">Vanilla good security practice vs. BadUSB</a> appeared first on <a href="https://labs.portcullis.co.uk">Portcullis Labs</a>.</p>]]></content:encoded>
			<wfw:commentRss>https://labs.portcullis.co.uk/blog/vanilla-good-security-practice-vs-badusb/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>An introduction to binary dynamic analysis</title>
		<link>https://labs.portcullis.co.uk/blog/an-introduction-to-binary-dynamic-analysis/</link>
		<comments>https://labs.portcullis.co.uk/blog/an-introduction-to-binary-dynamic-analysis/#comments</comments>
		<pubDate>Tue, 13 May 2014 13:29:24 +0000</pubDate>
		<dc:creator><![CDATA[BRC]]></dc:creator>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[analysis]]></category>
		<category><![CDATA[debugging]]></category>
		<category><![CDATA[fuzzing]]></category>

		<guid isPermaLink="false">https://labs.portcullis.co.uk/?p=3001</guid>
		<description><![CDATA[<p>The term dynamic instrumentation refers to the act of monitoring the execution of a program in order to extract debug information, to measure code performance or to detect errors. Dynamic instrumentation can be used to generate measures of functions properties such as execution time, call counts, registers status or call graphs. Tools Several software solutions [&#8230;]</p><p>The post <a href="https://labs.portcullis.co.uk/blog/an-introduction-to-binary-dynamic-analysis/">An introduction to binary dynamic analysis</a> appeared first on <a href="https://labs.portcullis.co.uk">Portcullis Labs</a>.</p>]]></description>
				<content:encoded><![CDATA[<p>The term <a title="dynamic instrumentation" href="http://en.wikipedia.org/wiki/Instrumentation_%28computer_programming%29">dynamic instrumentation</a> refers to the act of monitoring the execution of a program in order to extract debug information, to measure code performance or to detect errors. Dynamic instrumentation can be used to generate measures of functions properties such as execution time, call counts, registers status or call graphs.<br />
<span id="more-3001"></span></p>
<h2>Tools</h2>
<p>Several software solutions exists to help the developers and researchers to commit this task of inspecting a program runtime behaviour, being some of the prominent the following ones:</p>
<ul>
<li><a title="mtrace" href="http://man7.org/linux/man-pages/man3/mtrace.3.html">mtrace</a></li>
<li><a title="Valgrind" href="http://valgrind.org/">Valgrind</a></li>
<li><a title="Intel PIN tool" href="http://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool">Intel PIN tool</a></li>
<li><a title="DynamoRIO" href="http://code.google.com/p/dynamorio/">DynamoRIO</a></li>
<li><a title="DynInst" href="http://www.dyninst.org/">DynInst</a></li>
</ul>
<p>Two of the the most widely used tool dynamic binary instrumentation tools are PIN and DynamoRIO. PIN is developed by Intel and provided by the University of Virginia whereas DynamoRIO is a collaboration between Hewlett-Packard and MIT. Both are free to use but only DynamoRIO is open source. PIN and DynamoRIO are both equally useful and usually the election is the result of personal taste.</p>
<h3>mtrace</h3>
<p><a title="mtrace" href="http://man7.org/linux/man-pages/man3/mtrace.3.html">mtrace</a> is the memory debugger included in the GNU C Library. The usage of mtrace(3) can be summarised as follows:</p>
<ol>
<li>Export the variable MALLOC_TRACE to point to the result logfile</li>
<li>Include the header mcheck.h in the code</li>
<li>Call to mtrace() before allocating memory</li>
<li>Call untrace() at the end of the code (usually the main() function)</li>
<li>Compile the program with debugging symbols (gcc prog.c -g)</li>
<li>Read output using mtrace exec_file mtrace_output filename</li>
</ol>
<p>Following a example extracted from the mtrace(3) man page to clarify the usage:</p>
<pre class="brush: cpp; title: ; notranslate">
#include &lt;mcheck.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main()
{
   int j;

   mtrace();

   for (j = 0; j &lt; 2; j++)
       malloc(100);            /* Never freed--a memory leak */

   calloc(16, 16);             /* Never freed--a memory leak */
   exit(EXIT_SUCCESS);
}
</pre>
<p>A little script could be created in order to automate the compilation the analysis:</p>
<pre class="brush: bash; title: ; notranslate">
#!/bin/sh
export MALLOC_TRACE=mtrace.log
bin=prog
src=mtrace.c
gcc -g $src -o $bin
./$bin
mtrace $bin $MALLOC_TRACE
</pre>
<p>The execution will result in the following excerpt:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ ./mtrace.sh 

Memory not freed:
-----------------
           Address     Size     Caller
0x0000000002054460     0x64  at /home/user/mtrace.c:11 (discriminator 2)
0x00000000020544d0     0x64  at /home/user/mtrace.c:11 (discriminator 2)
0x0000000002054540    0x100  at /home/user/mtrace.c:15
</pre>
<p>As can be seen, mtrace(3) has detected the error absence of free(), resulting in a memory leak error.</p>
<h3>Intel PIN tool</h3>
<p>PIN is a framework for creating dynamic binary analysis tools for the i386 and x86-64 architectures that can be used to perform program analysis on user space applications in Linux and Windows at run time on the compiled binary files. Pin provides an API that abstracts the instruction set and the binary schema and allows to inspect register contents, program code and symbol and debug information.</p>
<p>PIN performs instrumentation by taking control of the program just after it loads into memory and recompiling just-in-time sections of binary code just before they are run. Regarding the performance, PIN&#8217;s overhead is about 30 percent.PIN was originally created as a tool for computer architecture analysis, but its flexible API and an active community (called &quot;Pinheads&quot;) have created a diverse set of tools for security, emulation and parallel program analysis.</p>
<p>A pin tool comprises of three types of routines: </p>
<ol>
<li>Instrumentation routines that enable the insertion of analysis routines</li>
<li>Analysis routines which are called when the code they are associated is run</li>
<li>Callback routines that called when specific conditions are met or when a certain event has occurred such as library loads, system calls, signals/exceptions and thread creation events</li>
</ol>
<p>PIN includes in the directories <strong>source/tools/ManualExamples</strong> and <strong>source/tools/SimpleExamples</strong>  several examples. Below can be seen the execution of the instruction counter and opcode mix profiler PIN tools:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ cd pin-2.12-58423-gcc.4.4.7-linux
$ ./pin -appdebug -t source/tools/ManualExamples/obj-ia32/inscount0.so -- `which evolution`
</pre>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ cd pin-2.12-58423-gcc.4.4.7-linux
$ ./pin -t source/tools/SimpleExamples/obj-intel64/opcodemix.so -- /bin/ls
</pre>
<p>Another interesting example can be found on the imageload.cpp file. This example demonstrates the use of the API functions IMG_AddInstrumentFunction and IMG_AddUnloadFunction which are called when the binary images are loaded by the operating system:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ cd source/tools/ManualExamples
$ make -f makefile obj-intel64/imageload.so
$ ../../../pin -t obj-intel64/imageload.so -- /bin/ls
$ cat imageload.out
	Loading /bin/ls, Image id = 1
	Loading /lib64/ld-linux-x86-64.so.2, Image id = 2
	Loading /lib/x86_64-linux-gnu/libselinux.so.1, Image id = 3
	Loading /lib/x86_64-linux-gnu/librt.so.1, Image id = 4
	Loading /lib/x86_64-linux-gnu/libacl.so.1, Image id = 5
	Loading /lib/x86_64-linux-gnu/libc.so.6, Image id = 6
	Loading /lib/x86_64-linux-gnu/libdl.so.2, Image id = 7
	Loading /lib/x86_64-linux-gnu/libpthread.so.0, Image id = 8
	Loading /lib/x86_64-linux-gnu/libattr.so.1, Image id = 9
	Unloading /bin/ls
	Unloading /lib64/ld-linux-x86-64.so.2
	Unloading /lib/x86_64-linux-gnu/libselinux.so.1
	Unloading /lib/x86_64-linux-gnu/librt.so.1
	Unloading /lib/x86_64-linux-gnu/libacl.so.1
	Unloading /lib/x86_64-linux-gnu/libc.so.6
	Unloading /lib/x86_64-linux-gnu/libdl.so.2
	Unloading /lib/x86_64-linux-gnu/libpthread.so.0
	Unloading /lib/x86_64-linux-gnu/libattr.so.1	
</pre>
<p>A classification of some of the shipped PIN tools examples are:</p>
<h4>Analysing instructions</h4>
<ul>
<li>inscount0.cpp: checks number of executed instructions of application program</li>
<li>itrace.cpp: lists addresses of executed instructions of application program</li>
<li>pinatrace.cpp: lists addresses of accessed memory and type of operation (read, write)</li>
<li>opcodemix.cpp: lists opcodes of executed instructions with number of executions and category summary</li>
<li>regmix.cpp: analyses the usage or program registers
</ul>
<h4>Analysing basic blocks</h4>
<ul>
<li>inscount1.cpp: counts all instructions of a basic block at once.</li>
<li>edgcnt.cpp:lists addresses of jump instructions, type of jump (direct, indirect), and number of times performed</li>
</ul>
<h4>Analysing routines</h4>
<ul>
<li>proccount.cpp: counts number of times each routine is invoked and number of instructions in it</li>
</ul>
<h3>Analysing libraries</h3>
<ul>
<li>imageload.cpp: lists loading and unloading of dynamic libraries invoked by program</li>
</ul>
<h4>Developing the first PIN tool</h4>
<p>PIN includes in source/tools/MyPinTool/ a sample tool that can be used as code code base to start creating basic PIN tools. To create, compile and execute a this basic example, the following commands could be used:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ cp -r pin-2.12-58423-gcc.4.4.7-linux/source/tools/MyPinTool/ pin1/
$ cd pin1
$ make -f makefile mPIN_ROOT=../pin-2.12-58423-gcc.4.4.7-linux
$ ls obj-intel64/
MyPinTool.o  MyPinTool.so
$ ../pin-2.12-58423-gcc.4.4.7-linux/pin -t obj-intel64/MyPinTool.so -- /bin/ls
===============================================
This application is instrumented by MyPinTool
===============================================
makefile  makefile.rules  MyPinTool.cpp  obj-intel64
</pre>
<p>To make things simple, a development directory &#8220;mytools&#8221; could be created outside the PIN directory hierarchy:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ ls -l
total 35636
drwxr-xr-x 4 user users     4096 mar  9 22:39 mytools
lrwxrwxrwx 1 user users       30 ago 24  2013 pin -&gt; pin-2.12-58423-gcc.4.4.7-linux
drwxr-xr-x 7 user users     4096 mar 10 01:12 pin-2.12-58423-gcc.4.4.7-linux
</pre>
<p>The development directory will contain the tools source code and the objects:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate"> 
$ ls -l mytools
total 120
-rw-r--r-- 1 user users  676 feb  3 2013 Makefile
-rwxr-xr-x 1 user users  366 feb  3 2013 build.sh
-rw-r--r-- 1 user users 6033 feb  9 05:08 check_pc_sections.cpp
-rw-r--r-- 1 user users 7062 feb  9 03:27 check_secciones.cpp
-rw-r--r-- 1 user users 7796 feb  9 04:44 detect_pc_noexec.cpp
-rw-r--r-- 1 user users 5278 feb  9 02:30 load_unload_imag.cpp
-rw-r--r-- 1 user users 5435 feb  9 02:44 load_unload_sec.cpp
-rw-r--r-- 1 user users 2822 feb  4  2013 makefile.rules
drwxr-xr-x 2 user users 4096 feb  3 18:46 obj-intel64
</pre>
<p>A script (build.sh) could be created in order to help the compilation of PIN tools that reside in the development directory. The code of the script could be as shown below:</p>
<pre class="brush: bash; title: ; notranslate">
#!/bin/sh
PIN_ROOT=../pin
dstdir=obj-intel64
function negrita() { echo -e &amp;quot;&#92;&#48;33[1m${1}&#92;&#48;33[0m&amp;quot;; }

test -d $dstdir || mkdir $dstdir

for f in *.cpp; do
    negrita &amp;quot;[*] Building $f&amp;quot;;
    obj=`echo $f | sed -e 's/cpp/so/'`
    make $dstdir/$obj PIN_ROOT=$PIN_ROOT
    negrita &amp;quot;[*] Exec $PIN_ROOT/pin -t $dstdir/$obj -- &lt;program&gt;&amp;quot;
done
</pre>
<p>This script can be used to compile or all tools contained in the &#8220;mytools&#8221; development directory at one. Also, some tricks could help when using this dynamic instrumentation framework:</p>
<ul>
<li>The option -appdebug tells PIN to start a GDB server to debug the application</li>
<li>The -appdebug option can also be used to debug from IDA Pro any application using PIN using the remote GDB debugger</li>
<li>It can&#8217;t be specified which port PIN will listen in as it will be randomly selected every time we execute PIN</li>
<ul>
<p>The post <a href="https://labs.portcullis.co.uk/blog/an-introduction-to-binary-dynamic-analysis/">An introduction to binary dynamic analysis</a> appeared first on <a href="https://labs.portcullis.co.uk">Portcullis Labs</a>.</p>]]></content:encoded>
			<wfw:commentRss>https://labs.portcullis.co.uk/blog/an-introduction-to-binary-dynamic-analysis/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Checking RDP support across an internal network</title>
		<link>https://labs.portcullis.co.uk/blog/checking-rdp-across-an-internal-network/</link>
		<comments>https://labs.portcullis.co.uk/blog/checking-rdp-across-an-internal-network/#comments</comments>
		<pubDate>Mon, 10 Feb 2014 06:32:00 +0000</pubDate>
		<dc:creator><![CDATA[BRC]]></dc:creator>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[RDP]]></category>
		<category><![CDATA[Windows]]></category>

		<guid isPermaLink="false">https://labs.portcullis.co.uk/?p=3051</guid>
		<description><![CDATA[<p>We&#8217;ve recently added some new features to rdp-sec-check, which is a Perl script to enumerate security settings of an RDP Service (AKA Terminal Services). The tool download is available in the rdp-sec-check page. The following new features were added to rdp-sec-check: Support for targets file Support for saving the tool output to a specified logfile [&#8230;]</p><p>The post <a href="https://labs.portcullis.co.uk/blog/checking-rdp-across-an-internal-network/">Checking RDP support across an internal network</a> appeared first on <a href="https://labs.portcullis.co.uk">Portcullis Labs</a>.</p>]]></description>
				<content:encoded><![CDATA[<p>We&#8217;ve recently added some new features to <a title="rdp-sec-check" href="https://labs.portcullis.co.uk/tools/rdp-sec-check/">rdp-sec-check</a>, which is a Perl script to enumerate security settings of an RDP Service (AKA Terminal Services). The tool download is available in the <a title="rdp-sec-check" href="https://labs.portcullis.co.uk/tools/rdp-sec-check/">rdp-sec-check</a> page.<span id="more-3051"></span></p>
<p>The following new features were added to rdp-sec-check:</p>
<ul>
<li>Support for targets file</li>
<li>Support for saving the tool output to a specified logfile</li>
<li>Control over the connection and responses timeouts</li>
<li>Control over the number of retries when timeouts occurs</li>
</ul>
<h2>rdp-sec-check command line help</h2>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ rdp-sec-check.pl
Starting rdp-sec-check v0.9-beta ( https://labs.portcullis.co.uk/application/rdp-sec-check/ )
Copyright (C) 2014 Mark Lowe (mrl@portcullis-security.com)

/usr/local/bin/rdp-sec-check.pl [ options ]  ( --file hosts.txt | host | host:port )

options are:

  --file hosts.txt	targets, one ip:port per line
  --outfile out.log	output logfile
  --timeout sec		receive timeout (default 10s)
  --retries times	number of retries after timeout
  --verbose
  --debug
  --help

Example:
         /usr/local/bin/rdp-sec-check.pl 192.168.1.1
         /usr/local/bin/rdp-sec-check.pl --file hosts.txt --timeout 15 --retries 3
         /usr/local/bin/rdp-sec-check.pl --outfile rdp.log 192.168.69.69:3389
         /usr/local/bin/rdp-sec-check.pl --file hosts.txt --outfile rdp.log --verbose

</pre>
<h2>Example output: A single Windows 2003 R2 RDP service scan</h2>
<p>The following is an example of a single machine scan using 3 seconds as timeout for connections and responses and output saving using the file named out.log:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ ./rdp-sec-check.pl --outfile out.log --timeout 3 192.168.13.13
Starting rdp-sec-check v0.9-beta ( https://labs.portcullis.co.uk/application/rdp-sec-check/ ) at Thu Jan 23 12:16:26 2014

[+] Scanning 1 hosts

Target:    192.168.13.13
IP:        192.168.13.13
Port:      3389

[+] Checking supported protocols

[-] Checking if RDP Security (PROTOCOL_RDP) is supported...Supported
[-] Checking if TLS Security (PROTOCOL_SSL) is supported...Not supported - SSL_CERT_NOT_ON_SERVER
[-] Checking if CredSSP Security (PROTOCOL_HYBRID) is supported [uses NLA]...Not supported - SSL_CERT_NOT_ON_SERVER

[+] Checking RDP Security Layer

[-] Checking RDP Security Layer with encryption ENCRYPTION_METHOD_NONE...Not supported
[-] Checking RDP Security Layer with encryption ENCRYPTION_METHOD_40BIT...Supported.  Server encryption level: ENCRYPTION_LEVEL_CLIENT_COMPATIBLE
[-] Checking RDP Security Layer with encryption ENCRYPTION_METHOD_128BIT...Supported.  Server encryption level: ENCRYPTION_LEVEL_CLIENT_COMPATIBLE
[-] Checking RDP Security Layer with encryption ENCRYPTION_METHOD_56BIT...Supported.  Server encryption level: ENCRYPTION_LEVEL_CLIENT_COMPATIBLE
[-] Checking RDP Security Layer with encryption ENCRYPTION_METHOD_FIPS...Supported.  Server encryption level: ENCRYPTION_LEVEL_CLIENT_COMPATIBLE

[+] Summary of protocol support

[-] 192.168.13.13:3389 supports PROTOCOL_RDP   : TRUE
[-] 192.168.13.13:3389 supports PROTOCOL_SSL   : FALSE
[-] 192.168.13.13:3389 supports PROTOCOL_HYBRID: FALSE

[+] Summary of RDP encryption support

[-] 192.168.13.13:3389 has encryption level: ENCRYPTION_LEVEL_CLIENT_COMPATIBLE
[-] 192.168.13.13:3389 supports ENCRYPTION_METHOD_NONE   : FALSE
[-] 192.168.13.13:3389 supports ENCRYPTION_METHOD_40BIT  : TRUE
[-] 192.168.13.13:3389 supports ENCRYPTION_METHOD_128BIT : TRUE
[-] 192.168.13.13:3389 supports ENCRYPTION_METHOD_56BIT  : TRUE
[-] 192.168.13.13:3389 supports ENCRYPTION_METHOD_FIPS   : TRUE

[+] Summary of security issues

[-] 192.168.13.13:3389 has issue FIPS_SUPPORTED_BUT_NOT_MANDATED
[-] 192.168.13.13:3389 has issue WEAK_RDP_ENCRYPTION_SUPPORTED
[-] 192.168.13.13:3389 has issue ONLY_RDP_SUPPORTED_MITM
[-] 192.168.13.13:3389 has issue NLA_NOT_SUPPORTED_DOS

rdp-sec-check v0.9-beta completed at Thu Jan 23 12:16:27 2014
</pre>
<h2>Example: A fast network scan using timeouts and retries</h2>
<p>In this example, a targets file to test the network 172.18.19.0/24 is generated using a shell one liner:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ for i in $(seq 1 254); do echo 172.18.19.$i; done &gt;&gt; targets.txt
</pre>
<p>Then rdp-sec-check is fed with the targets file targets.txt and a 3 second limit is set on the connections and responses; if the connections times out, rdp-sec-check will retry 2 times before exiting. Finally, the scan log will be saved in the file out.log.</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ ./rdp-sec-check.pl --file targets.txt --outfile out.log --timeout 3 --retries 2
</pre>
<p>In this example, the timeout and retries parameters are set for a fast local network scan. When scanning machines through the Internet or VPN, the timeout should be set to a higher value. Also, depending on the stability of the targets and/or the pentester&#8217;s Internet connection, the value of the parameter retries should be tuned.</p>
<h2>Example: A Internet network scan using timeouts and retries</h2>
<p>In this example, I have configured rdp-sec-check with a targets file named targets.txt and a 15 seconds time limit on the connections and responses (with a fault tolerance of 5). Again, all the output will be saved in the file named out.log. This parameter settings should help rdp-sec-check to succeed where the network connectivity is unreliable: </p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ ./rdp-sec-check.pl --file targets.txt --outfile out.log --timeout 15 --retries 5
</pre>
<p>The post <a href="https://labs.portcullis.co.uk/blog/checking-rdp-across-an-internal-network/">Checking RDP support across an internal network</a> appeared first on <a href="https://labs.portcullis.co.uk">Portcullis Labs</a>.</p>]]></content:encoded>
			<wfw:commentRss>https://labs.portcullis.co.uk/blog/checking-rdp-across-an-internal-network/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>OHM 2013: Review of &#8220;Returning signals for fun and profit&#8221;</title>
		<link>https://labs.portcullis.co.uk/blog/ohm-2013-review-of-returning-signals-for-fun-and-profit/</link>
		<comments>https://labs.portcullis.co.uk/blog/ohm-2013-review-of-returning-signals-for-fun-and-profit/#comments</comments>
		<pubDate>Tue, 05 Nov 2013 14:38:10 +0000</pubDate>
		<dc:creator><![CDATA[BRC]]></dc:creator>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[analysis]]></category>
		<category><![CDATA[ASLR]]></category>
		<category><![CDATA[conference]]></category>
		<category><![CDATA[OHM2013]]></category>

		<guid isPermaLink="false">https://labs.portcullis.co.uk/?p=1458</guid>
		<description><![CDATA[<p>One interesting talk I&#8217;ve attended on OHM 2013 was titled &#8220;Returning Signals for fun and profit&#8221;. This talk was given by Erik Bosman. The talk refers to a new way exploiting binaries using the Linux signal&#8217;s stack frame. This post could be summarised with the following words: Return oriented programming has been proven to be [&#8230;]</p><p>The post <a href="https://labs.portcullis.co.uk/blog/ohm-2013-review-of-returning-signals-for-fun-and-profit/">OHM 2013: Review of &#8220;Returning signals for fun and profit&#8221;</a> appeared first on <a href="https://labs.portcullis.co.uk">Portcullis Labs</a>.</p>]]></description>
				<content:encoded><![CDATA[<p>One interesting talk I&#8217;ve attended on OHM 2013 was titled &#8220;Returning Signals for fun and profit&#8221;. This talk was given by Erik Bosman. The talk refers to a new way exploiting binaries using the Linux signal&#8217;s stack frame.<span id="more-1458"></span></p>
<p>This post could be summarised with the following words:</p>
<p><a title="Return oriented programming" href="http://en.wikipedia.org/wiki/Return-oriented_programming">Return oriented programming</a> has been proven to be a very effective way of circumventing data execution prevention features like <a title="ASLR" href="http://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a> present in modern operating systems, but the attacker needs to know the binary structure of the target executable in order to extract the so-called <a href="http://users.suse.com/~krahmer/no-nx.pdf‎">borrowed chunks of code</a>. Here a generic binary exploitation technique will be covered which in some cases requires no knowledge about the running program.</a></p>
<h2>Contexts and switches</h2>
<p>A clever way to alter the control flow of the program by using <a title="context control" href="http://www.linfo.org/context_switch.html">context control</a> will be described. A program execution context comprises the CPU&#8217;s registers, the program counter plus other operating system specific data at any point in time. A context switch is the process of storing and restoring the state of a process so that execution can be resumed from the same point at a later time. There are two types of context switches: software and hardware.</p>
<p>In this post I will cover the software context switch used in the process of a task returning from a software signal on 64bits. The Linux implementation of signals is fully POSIX-compliant, and the data used to recover the task from a previus state (the interrupted context: registers, program counter, signal mask, etc.) is be saved in a ucontext_t structure on the stack for the thread, along with the trampoline return address. Signal handlers installed with the SA_SIGINFO flag are able to examine this ucontext_t structure. The definition of the structure ucontext can be seen in the include/uapi/asm-generic/ucontext.h header file:</p>
<pre class="brush: cpp; first-line: 1; title: ; notranslate">
#ifndef __ASM_GENERIC_UCONTEXT_H
#define __ASM_GENERIC_UCONTEXT_H

struct ucontext {
        unsigned long     uc_flags;
        struct ucontext  *uc_link;
        stack_t           uc_stack;
        struct sigcontext uc_mcontext;
        sigset_t          uc_sigmask;   /* mask last for extensibility */
};

#endif /* __ASM_GENERIC_UCONTEXT_H */
</pre>
<p>The structure sigcontext, which holds the saved state of the task (registers, etc) can be examined in the arch/x86/include/asm/sigcontext.h header file:</p>
<pre class="brush: cpp; first-line: 40; title: ; notranslate">
struct sigcontext {
        unsigned long r8;
        unsigned long r9;
        unsigned long r10;
        unsigned long r11;
        unsigned long r12;
        unsigned long r13;
        unsigned long r14;
        unsigned long r15;
        unsigned long di;
        unsigned long si;
        unsigned long bp;
        unsigned long bx;
        unsigned long dx;
        unsigned long ax;
        unsigned long cx;
        unsigned long sp;
        unsigned long ip;
        unsigned long flags;
        unsigned short cs;
        unsigned short gs;
        unsigned short fs;
        unsigned short __pad0;
        unsigned long err;
        unsigned long trapno;
        unsigned long oldmask;
        unsigned long cr2;

        /*
         * fpstate is really (struct _fpstate *) or (struct _xstate *)
         * depending on the FP_XSTATE_MAGIC1 encoded in the SW reserved
         * bytes of (struct _fpstate) and FP_XSTATE_MAGIC2 present at the end
         * of extended memory layout. See comments at the definition of
         * (struct _fpx_sw_bytes)
         */
        void __user *fpstate;           /* zero when no FPU/extended context */
        unsigned long reserved1[8];
};
</pre>
<p>The struct _fpstate __user *fpstate is defined in the arch/x86/include/uapi/asm/sigcontext.h header file:</p>
<pre class="brush: cpp; first-line: 69; title: ; notranslate">
struct _fpstate {
        /* Regular FPU environment */
        unsigned long   cw;
        unsigned long   sw;
        unsigned long   tag;
        unsigned long   ipoff;
        unsigned long   cssel;
        unsigned long   dataoff;
        unsigned long   datasel;
        struct _fpreg   _st[8];
        unsigned short  status;
        unsigned short  magic;          /* 0xffff = regular FPU data only */

        /* FXSR FPU environment */
        unsigned long   _fxsr_env[6];   /* FXSR FPU env is ignored */
        unsigned long   mxcsr;
        unsigned long   reserved;
        struct _fpxreg  _fxsr_st[8];    /* FXSR FPU reg data is ignored */
        struct _xmmreg  _xmm[8];
        unsigned long   padding1[44];

        union {
                unsigned long   padding2[12];
                struct _fpx_sw_bytes sw_reserved; /* represents the extended
                                                   * state info */
        };
};
</pre>
<p>Finally, the signal information structure struct siginfo is available in include/uapi/asm-generic/siginfo.h:</p>
<p>From include/uapi/asm-generic/siginfo.h:</p>
<pre class="brush: cpp; first-line: 48; title: ; notranslate">
typedef struct siginfo {
        int si_signo;
        int si_errno;
        int si_code;

        union {
                int _pad[SI_PAD_SIZE];

                /* kill() */
                struct {
                        __kernel_pid_t _pid;    /* sender's pid */
                        __ARCH_SI_UID_T _uid;   /* sender's uid */
                } _kill;

                /* POSIX.1b timers */
                struct {
                        __kernel_timer_t _tid;  /* timer id */
                        int _overrun;           /* overrun count */
                        char _pad[sizeof( __ARCH_SI_UID_T) - sizeof(int)];
                        sigval_t _sigval;       /* same as below */
                        int _sys_private;       /* not to be passed to user */
                } _timer;

                /* POSIX.1b signals */
                struct {
                        __kernel_pid_t _pid;    /* sender's pid */
                        __ARCH_SI_UID_T _uid;   /* sender's uid */
                        sigval_t _sigval;
                } _rt;

                /* SIGCHLD */
                struct {
                        __kernel_pid_t _pid;    /* which child */
                        __ARCH_SI_UID_T _uid;   /* sender's uid */
                        int _status;            /* exit code */
                        __ARCH_SI_CLOCK_T _utime;
                        __ARCH_SI_CLOCK_T _stime;
                } _sigchld;

                /* SIGILL, SIGFPE, SIGSEGV, SIGBUS */
                struct {
                        void __user *_addr; /* faulting insn/memory ref. */
#ifdef __ARCH_SI_TRAPNO
                        int _trapno;    /* TRAP # which caused the signal */
#endif
                        short _addr_lsb; /* LSB of the reported address */
                } _sigfault;

                /* SIGPOLL */
                struct {
                        __ARCH_SI_BAND_T _band; /* POLL_IN, POLL_OUT, POLL_MSG */
                        int _fd;
                } _sigpoll;

                /* SIGSYS */
                struct {
                        void __user *_call_addr; /* calling user insn */
                        int _syscall;   /* triggering system call number */
                        unsigned int _arch;     /* AUDIT_ARCH_* of syscall */
                } _sigsys;
        } _sifields;
} __ARCH_SI_ATTRIBUTES siginfo_t;
</pre>
<p>As a summary, the the following kernel source files play a part in this technique:</p>
<pre class="brush: cpp; gutter: false; highlight: [1,4,9]; title: ; notranslate">
arch/x86/include/uapi/asm/sigcontext32.h (32bits)
   	struct _fpstate_ia32
   	struct sigcontext_ia32
arch/x86/include/uapi/asm/sigcontext.h
   	struct _fpstate
	#ifndef __KERNEL__
   	 	struct sigcontext (contains void __user *fpstate; )
	#endif /* !__KERNEL__ */
arch/x86/include/asm/sigcontext.h
 	#include &amp;lt;uapi/asm/sigcontext.h&amp;gt;
   	struct sigcontext ( contains void __user *fpstate; )&lt;/pre&gt;
</pre>
<p>The good thing about storing this data on the stack is that the kernel does not need to remember the signals it delivered, but the bad point is that It can be forged.</p>
<p>When switching context, the kernel will execute setup_rt_frame, where all user-space registers are saved and the kernel stack frame return address is modified to point to the handler of the installed signal handler. A small sequence of code jumper is put on the user stack which will return us to kernel space once the signal handler has finished.</p>
<p>From arch/x86/kernel/signal.c:</p>
<pre class="brush: cpp; first-line: 669; title: ; notranslate">
static int
setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,
                struct pt_regs *regs)
{
        int usig = signr_convert(sig);
        sigset_t *set = sigmask_to_save();
        compat_sigset_t *cset = (compat_sigset_t *) set;

        /* Set up the stack frame */
        if (is_ia32_frame()) {
                if (ka-&gt;sa.sa_flags &amp; SA_SIGINFO)
                        return ia32_setup_rt_frame(usig, ka, info, cset, regs);
                else
                        return ia32_setup_frame(usig, ka, cset, regs);
        } else if (is_x32_frame()) {
                return x32_setup_rt_frame(usig, ka, info, cset, regs);
        } else {
                return __setup_rt_frame(sig, ka, info, set, regs);
        }
}
</pre>
<p>From arch/x86/kernel/signal.c:</p>
<pre class="brush: cpp; first-line: 408; title: ; notranslate">
static int __setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,
                            sigset_t *set, struct pt_regs *regs)
{
        struct rt_sigframe __user *frame;
        void __user *fp = NULL;
        int err = 0;

        frame = get_sigframe(ka, regs, sizeof(struct rt_sigframe), &amp;fp);

        if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))
                return -EFAULT;

        if (ka-&gt;sa.sa_flags &amp; SA_SIGINFO) {
                if (copy_siginfo_to_user(&amp;frame-&gt;info, info))
                        return -EFAULT;
        }

        put_user_try {
                /* Create the ucontext.  */
                if (cpu_has_xsave)
                        put_user_ex(UC_FP_XSTATE, &amp;frame-&gt;uc.uc_flags);
                else
                        put_user_ex(0, &amp;frame-&gt;uc.uc_flags);
                put_user_ex(0, &amp;frame-&gt;uc.uc_link);
                err |= __save_altstack(&amp;frame-&gt;uc.uc_stack, regs-&gt;sp);

                /* Set up to return from userspace.  If provided, use a stub
                   already in userspace.  */
                /* x86-64 should always use SA_RESTORER. */
                if (ka-&gt;sa.sa_flags &amp; SA_RESTORER) {
                        put_user_ex(ka-&gt;sa.sa_restorer, &amp;frame-&gt;pretcode);
                } else {
                        /* could use a vstub here */
                        err |= -EFAULT;
                }
        } put_user_catch(err);

        err |= setup_sigcontext(&amp;frame-&gt;uc.uc_mcontext, fp, regs, set-&gt;sig[0]);
        err |= __copy_to_user(&amp;frame-&gt;uc.uc_sigmask, set, sizeof(*set));

        if (err)
                return -EFAULT;

        /* Set up registers for signal handler */
        regs-&gt;di = sig;
        /* In case the signal handler was declared without prototypes */
        regs-&gt;ax = 0;

        /* This also works for non SA_SIGINFO handlers because they expect the
           next argument after the signal number on the stack. */
        regs-&gt;si = (unsigned long)&amp;frame-&gt;info;
        regs-&gt;dx = (unsigned long)&amp;frame-&gt;uc;
        regs-&gt;ip = (unsigned long) ka-&gt;sa.sa_handler;

        regs-&gt;sp = (unsigned long)frame;

        /* Set up the CS register to run signal handlers in 64-bit mode,
           even if the handler happens to be interrupting 32-bit code. */
        regs-&gt;cs = __USER_CS;

        return 0;
}
</pre>
<p>The above code restores the exact user-register contents into the kernel stack frame (including the return address and flags register) and executes a normal return from syscall, bringing the execution flow back to the original code that jumped to the signal handler.</p>
<p>The stack frame image that Linux configures for signal returning assembles the following diagram:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
 [-------------]
 [    STACK    ]
 [-------------]
 [   FPSTATE   ]
 [-------------]
 [   UCONTEXT  ]
 [-------------]
 [ SIGINFO+arg ]
 [-------------]
</pre>
<p>A detailed view on 64bits should assemble the following diagram:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
     [------------------------------------------]
0x00 [  rt_sigreturn()      |  uc_flags         ]
0x10 [  &amp;uc                 |  uc_stack.ss_sp   ]
0x20 [  uc_stack.ss_flags   |  uc_stack.ss_size ]
0x30 [  r8                  |  r9               ]
0x40 [  r10                 |  r11              ]
0x50 [  r12                 |  r13              ]
0x60 [  r14                 |  r15              ]
0x70 [  rdi                 |  rsi              ]
0x80 [  rbp                 |  rbx              ]
0x90 [  rdx                 |  rax              ]
0xA0 [  rcx                 |  rsp              ]
0xB0 [  rip                 |  eflags           ]
0xC0 [  cs / gs / fs        |  err              ]
0xD0 [  trapno              |  oldmask (unused) ]
0xE0 [  cr2 (segfault addr) |  &amp;fpstate         ]
0xF0 [  __reserved          |  sigmask          ]
     [------------------------------------------]
</pre>
<h2>Exploitation</h2>
<p>By forging the contents of the struct sigcontext, which holds the saved registers values, setting the $rax register to the desired syscall number, setting the systemcall args properly and finally setting the program counter $rip pointing to an >syscall; ret gadget, we can effectively modify the execution flow of the program and execute the desired systemcall. Also, several SigRet frames can be chained by using the value of the saved $rsp register of the returning frame and the gadget syscall;ret.</p>
<ul>
<li>rax =&gt; syscall_number</li>
<li>rdi =&gt; arg1</li>
<li>rsi =&gt; arg2</li>
<li>rdx =&gt; arg3</li>
<li>r10 =&gt; arg4</li>
<li>r8 =&gt; arg5</li>
<li>r9 =&gt; arg6</li>
<li>rip =&gt; syscall;ret</li>
<li>rsp =&gt; next_frame</li>
<li>cs=0&#215;33 / gs=0&#215;0 / fs=0&#215;0</li>
<li>&amp;fpstate = NULL</li>
</ul>
<p>The forged stack structure should assemble the following:</p>
<pre class="brush: bash; gutter: false; highlight: [1,4,5,8,10,11,12,13,15]; title: ; notranslate">
     [------------------------------------------]
0x00 [  rt_sigreturn()      |  uc_flags         ]*
0x10 [  &amp;uc                 |  uc_stack.ss_sp   ]
0x20 [  uc_stack.ss_flags   |  uc_stack.ss_size ]
0x30 [  arg5                |  arg6             ]*
0x40 [  arg4                |  r11              ]*
0x50 [  r12                 |  r13              ]
0x60 [  r14                 |  r15              ]
0x70 [  arg1                |  arg2             ]*
0x80 [  rbp                 |  rbx              ]
0x90 [  arg3                |  syscall_number   ]*
0xA0 [  rcx                 |  next_frame       ]*
0xB0 [  syscall;ret         |  eflags           ]*
0xC0 [  cs=0x33/gs=0/fs=0   |  err              ]*
0xD0 [  trapno              |  oldmask (unused) ]
0xE0 [  cr2 (segfault addr) |  &amp;fpstate         ]*
0xF0 [  __reserved          |  sigmask          ]
     [------------------------------------------]
</pre>
<p>As a summary, for SigReturn oriented programming, the following requirements are needed:</p>
<ol>
<li>Controllable stack</li>
<li>Knowing the address of a system call gadget</li>
<li>A known writable address</li>
<li>Known file descriptor</li>
<li>Control over the RAX register</li>
</ol>
<p>More information:</p>
<ul>
<li>man(2) getcontext</li>
<li>man(2) setcontext</li>
<li><a title="Returning signals for fun and profit" href="https://program.ohm2013.org/event/233.html">Returning signals for fun and profit</a></li>
<li><a title="Context switch" href="http://www.linfo.org/context_switch.html">Context switch</a></li>
<li><a title="The Linux Signal Handling Model" href="http://www.linuxjournal.com/article/3985">The Linux Signal Handling Model</a></li>
<li><a title="The GNU C Library - Signal Handling" href="http://www.cs.utah.edu/dept/old/texinfo/glibc-manual-0.02/library_21.html">The GNU C Library &#8211; Signal Handling</a></li>
<li><a title="Wikipedia - Context switch" href="http://en.wikipedia.org/wiki/Context_switch">Wikipedia &#8211; Context switch</a></li>
<li><a title="Wikipedia - Getcontext" href="http://en.wikipedia.org/wiki/Getcontext">Wikipedia &#8211; Getcontext</a></li>
<li><a title="Wikipedia - Setcontext" href="http://en.wikipedia.org/wiki/Setcontext">Wikipedia &#8211; Setcontext</a></li>
</ul>
<p>The post <a href="https://labs.portcullis.co.uk/blog/ohm-2013-review-of-returning-signals-for-fun-and-profit/">OHM 2013: Review of &#8220;Returning signals for fun and profit&#8221;</a> appeared first on <a href="https://labs.portcullis.co.uk">Portcullis Labs</a>.</p>]]></content:encoded>
			<wfw:commentRss>https://labs.portcullis.co.uk/blog/ohm-2013-review-of-returning-signals-for-fun-and-profit/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
