<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Portcullis Labs &#187; CVE-2014-6271</title>
	<atom:link href="https://portcullislabs.github.io/tag/cve-2014-6271/feed/" rel="self" type="application/rss+xml" />
	<link>https://portcullislabs.github.io</link>
	<description>Research and Development</description>
	<language>en-US</language>
		<sy:updatePeriod>hourly</sy:updatePeriod>
		<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.8.5</generator>
	<item>
		<title>CVE-2014-6271 (Shellshock): The story of a permissive parser</title>
		<link>https://portcullislabs.github.io/blog/cve-2014-6271-shellshock-the-story-of-a-permissive-parser/</link>
		<comments>https://portcullislabs.github.io/blog/cve-2014-6271-shellshock-the-story-of-a-permissive-parser/#comments</comments>
		<pubDate>Mon, 29 Sep 2014 15:23:08 +0000</pubDate>
		<dc:creator><![CDATA[MTB]]></dc:creator>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[analysis]]></category>
		<category><![CDATA[CVE-2014-6271]]></category>
		<category><![CDATA[exploit]]></category>
		<category><![CDATA[UNIX]]></category>

		<guid isPermaLink="false">https://portcullislabs.github.io/?p=4663</guid>
		<description><![CDATA[<p>Some bugs are so simple and so elegant that you wonder how it is possible that no one has found them until now. Those are my favorites. They are simple, they do not involve memory corruption and most of the time they do not even need an advanced exploit code to abuse it. Stéphane Chazelas&#8217; [&#8230;]</p><p>The post <a href="https://portcullislabs.github.io/blog/cve-2014-6271-shellshock-the-story-of-a-permissive-parser/">CVE-2014-6271 (Shellshock): The story of a permissive parser</a> appeared first on <a href="https://portcullislabs.github.io">Portcullis Labs</a>.</p>]]></description>
				<content:encoded><![CDATA[<p>Some bugs are so simple and so elegant that you wonder how it is possible that no one has found them until now. Those are my favorites. They are simple, they do not involve memory corruption and most of the time they do not even need an advanced exploit code to abuse it. Stéphane Chazelas&#8217; Bash bug is one of these bugs.<span id="more-4663"></span></p>
<p>Note: Many other bugs related to Bash parser were discovered in the past few days such as CVE-2014-6277, CVE-2014-7169, CVE-2014-7186, CVE-2014-7187 and some others that have not yet been made public. This article is only about CVE-2014-6271.</p>
<h2>Bash and functions</h2>
<p>With <a title="Bash" href="http://www.gnu.org/software/bash/">Bash</a> it is possible to define functions. This is done as follows.</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ myfunction () { id; }
$ myfunction
uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(sambashare),113(libvirtd),114(lpadmin)
</pre>
<p>Bash also comes with a nifty feature. It allows functions to be exported and passed as an environment variable. This is done as follows:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
() { id; }
</pre>
<p>It is possible to pass this function to a new <em>bash</em> process.</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ myfunc='() { id; }' bash
$ myfunc
uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(sambashare),113(libvirtd),114(lpadmin)
</pre>
<p>Indeed, when the myfunc function is called, the id command is executed.</p>
<h2>Installing a testing environment</h2>
<p>First install Ubuntu 14.04.1 LTS available here: http://releases.ubuntu.com/14.04/.</p>
<p>Make sure you have a vulnerable bash version <img src="https://portcullislabs.github.io/wp-includes/images/smilies/icon_smile.gif" alt=":-)" class="wp-smiley" /> </p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
# wget http://security.ubuntu.com/ubuntu/pool/main/b/bash/bash_4.3-6ubuntu1_amd64.deb
# dpkg -i bash_4.3-6ubuntu1_amd64.deb
</pre>
<h2>Vulnerability</h2>
<p>Let&#8217;s have a look at bash 4.2 source code to see how it works.</p>
<p>First, in the general.h file, the STREQN() function is defined. It is a simple wrapper to the strncmp() function.</p>
<pre class="brush: cpp; gutter: false; title: ; notranslate">
/* String comparisons that possibly save a function call each. */
#define STREQN(a, b, n) ((n == 0) ? (1) \
				  : ((a)[0] == (b)[0] &amp;&amp; strncmp(a, b, n) == 0))
</pre>
<p>The way environment variables are handled is done in the initialize_shell_variables() function located in the variable.c file. It loops through each variables and if it finds an exported function, it defines it by running it. To catch if it is an exported function, it compares the string&#8217;s content with &#8220;() {&#8220;. If found, the complete string is evaluated and executed using the parse_and_execute() function.</p>
<pre class="brush: cpp; highlight: [2,18,27]; title: ; notranslate">
void
initialize_shell_variables (env, privmode)
     char **env;
     int privmode;
{
  char *name, *string, *temp_string;
  int c, char_index, string_index, string_length;
  SHELL_VAR *temp_var;

[...]

  for (string_index = 0; string = env[string_index++]; )

[...]

      /* If exported function, define it now.  Don't import functions from
	 the environment in privileged mode. */
      if (privmode == 0 &amp;&amp; read_but_dont_execute == 0 &amp;&amp; STREQN (&quot;() {&quot;, string, 4))
	{
	  string_length = strlen (string);
	  temp_string = (char *)xmalloc (3 + string_length + char_index);

	  strcpy (temp_string, name);
	  temp_string[char_index] = ' ';
	  strcpy (temp_string + char_index + 1, string);

	  parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST);

	  /* Ancient backwards compatibility.  Old versions of bash exported
	     functions like name()=() {...} */
	  if (name[char_index - 1] == ')' &amp;&amp; name[char_index - 2] == '(')
	    name[char_index - 2] = '&#92;&#48;';
</pre>
<p>As seen before, the <em>myfunc</em> bash function is not executed, it is only parsed and defined. But reading the source code, the whole string is parsed and executed, not only the function definition. If some code is inserted after the function definition, it should also be executed. This is easy to verify:</p>
<pre class="brush: bash; gutter: false; title: ; notranslate">
$ myfunc='() { id;}; echo &quot;This should not be executed but it is.&quot;' bash -c &quot;echo legit shell&quot;
This should not be executed but it is.
legit shell
</pre>
<p>There may be multiple exploit vectors, mainly every time an environment variable can be passed to a new instance of Bash.<br />
For instance:</p>
<ul>
<li>A CGI using HTTP_USER_AGENT variable</li>
<li>OpenSSH on a restricted shell and the SSH_ORIGINAL_COMMAND variable</li>
<li>dhclient with a custom domain-name</li>
<li>Many more to find</li>
</ul>
<p>The post <a href="https://portcullislabs.github.io/blog/cve-2014-6271-shellshock-the-story-of-a-permissive-parser/">CVE-2014-6271 (Shellshock): The story of a permissive parser</a> appeared first on <a href="https://portcullislabs.github.io">Portcullis Labs</a>.</p>]]></content:encoded>
			<wfw:commentRss>https://portcullislabs.github.io/blog/cve-2014-6271-shellshock-the-story-of-a-permissive-parser/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
